// Generated by CoffeeScript 1.10.0
(function() {
  var expect, mockPath, mockWithGlobalDep, mockWithImportPath, mockWithInjectorImportPath, mockWithNpmImportPath;

  expect = require('chai').expect;

  global.injector = require('../index.coffee');

  mockPath = require.resolve('./mocks/mathModule.coffee');

  mockWithImportPath = require.resolve('./mocks/mathModuleWithImport.coffee');

  mockWithNpmImportPath = require.resolve('./mocks/mathModuleWithNpmImport.coffee');

  mockWithInjectorImportPath = require.resolve('./mocks/mathModuleThatImportsAnInjectorWrapper.coffee');

  global.PI = Math.PI;

  mockWithGlobalDep = require.resolve('./mocks/mockWithGlobalDep.coffee');

  describe('commonjs-injector Module', function() {
    it('should have a "set" method', function() {
      return expect(injector.set).to.be.a('function');
    });
    it('should have a "get" method', function() {
      return expect(injector.get).to.be.a('function');
    });
    it('should have an "import" method', function() {
      return expect(injector["import"]).to.be.a('function');
    });
    it('should have a "bypassInjection" method', function() {
      return expect(injector.bypassInjection).to.be.a('function');
    });
    it('should have an "setEnv" method', function() {
      return expect(injector.setEnv).to.be.a('function');
    });
    it('should have an "getEnv" method', function() {
      return expect(injector.getEnv).to.be.a('function');
    });
    it('should return the module when calling the bypassInjection method', function() {
      return expect(injector.bypassInjection(true)).to.equal(injector);
    });
    it('should return the module when calling the "setEnv" method', function() {
      return expect(injector.setEnv('testing')).to.equal(injector);
    });
    it('should throw an error when setEnv is called with an invalid environment string', function() {
      var fn;
      fn = function() {
        return injector.setEnv('lorem');
      };
      return expect(fn).to["throw"](Error);
    });
    it('should return the previously defined environment when calling "getEnv"', function() {
      expect(injector.setEnv('testing')).to.equal(injector);
      return expect(injector.getEnv()).to.equal('testing');
    });
    describe('.set', function() {
      return it('should return the defined module', function() {
        var module;
        module = injector.set(function(dependencies) {
          this.dependencies = dependencies;
          return {
            foo: 'bar'
          };
        })();
        return expect(module.foo).to.equal('bar');
      });
    });
    describe('When bypassInjection is set to true (default)', function() {
      beforeEach(function() {
        return injector.bypassInjection(true);
      });
      it('should let you export a module as a regular node.js module', function() {
        var mathModule;
        mathModule = require(mockPath);
        expect(mathModule).to.be.an('object');
        expect(mathModule.square(5)).to.equal(25);
        return delete require.cache[mockPath];
      });
      it('should let you use @import inside the injector fn to require regular modules', function() {
        var mathModule;
        mathModule = require(mockWithImportPath);
        expect(mathModule.pi).to.equal(Math.PI);
        return delete require.cache[mockWithImportPath];
      });
      it('should let you use @import inside the injector fn to require npm modules', function() {
        var mathModule;
        mathModule = require(mockWithNpmImportPath);
        expect(mathModule.pi).to.equal(Math.PI);
        return delete require.cache[mockWithNpmImportPath];
      });
      return it('should let you use @importGlobal inside the injector fn to require a global', function() {
        var mathModule;
        mathModule = require(mockWithGlobalDep);
        expect(mathModule.pi).to.equal(global.PI);
        return delete require.cache[mockWithGlobalDep];
      });
    });
    return describe('When bypassInjection is set to false', function() {
      beforeEach(function() {
        return injector.bypassInjection(false);
      });
      it('should let you export a fn wrapper that accepts an object with dependencies and returns the module when called', function() {
        var mathModule, mathModuleWrapper;
        mathModuleWrapper = require(mockPath);
        expect(mathModuleWrapper).to.be.an('function');
        mathModule = mathModuleWrapper();
        expect(mathModule).to.be.an('object');
        return delete require.cache[mockPath];
      });
      it('should let you export a fn wrapper that accepts an object with dependencies and uses @import internally', function() {
        var mathModule, mathModuleWrapper;
        mathModuleWrapper = require(mockWithImportPath);
        expect(mathModuleWrapper).to.be.an('function');
        mathModule = mathModuleWrapper();
        expect(mathModule).to.be.an('object');
        expect(mathModule.pi).to.equal(Math.PI);
        return delete require.cache[mockWithImportPath];
      });
      it('should let you export a fn wrapper that accepts an object with dependencies(wrapped with an injector fn) and uses @import internally', function() {
        var mathModule, mathModuleWrapper;
        mathModuleWrapper = require(mockWithInjectorImportPath);
        expect(mathModuleWrapper).to.be.an('function');
        mathModule = mathModuleWrapper();
        expect(mathModule).to.be.an('object');
        expect(mathModule.pi).to.equal(Math.PI);
        return delete require.cache[mockWithImportPath];
      });
      it('should let you inject dependencies that are required internally via @import', function() {
        var mathModule, mathModuleWrapper;
        mathModuleWrapper = require(mockWithImportPath);
        mathModule = mathModuleWrapper({
          'PiModule': 'Mocked PI Value'
        });
        expect(mathModule).to.be.an('object');
        expect(mathModule.pi).to.equal('Mocked PI Value');
        return delete require.cache[mockWithImportPath];
      });
      it('should let you inject dependencies that are required as globals internally via @importGlobal()', function() {
        var mathModule, mathModuleWrapper;
        mathModuleWrapper = require(mockWithGlobalDep);
        mathModule = mathModuleWrapper({
          'PI': 'Mocked PI Value'
        });
        expect(mathModule.pi).to.equal('Mocked PI Value');
        return delete require.cache[mockWithGlobalDep];
      });
      return describe('import method', function() {
        return it('should let you import a module, and bypass the injector wrapper if there is one', function() {
          var pi;
          pi = injector["import"]('test/mocks/injectorPiModule');
          return expect(pi).to.equal(Math.PI);
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=index.spec.js.map
